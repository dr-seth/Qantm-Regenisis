"""
Base Strategy for Trading Vertical

This module provides the base class for all trading strategies, ensuring
consistent interfaces for backtesting, paper trading, and live execution.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

import numpy as np
import pandas as pd


class SignalType(Enum):
    """Types of trading signals."""
    
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


class OrderType(Enum):
    """Types of orders."""
    
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


@dataclass
class Signal:
    """A trading signal generated by a strategy."""
    
    signal_type: SignalType
    symbol: str
    timestamp: datetime
    confidence: float  # 0.0 to 1.0
    strategy_id: str
    order_type: OrderType = OrderType.MARKET
    limit_price: Optional[float] = None
    stop_price: Optional[float] = None
    quantity: Optional[float] = None  # None means use position sizing rules
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")


@dataclass
class StrategyConfig:
    """Configuration for a trading strategy."""
    
    strategy_id: str
    name: str
    description: str
    version: str = "1.0.0"
    symbols: List[str] = field(default_factory=list)
    timeframe: str = "1h"  # e.g., "1m", "5m", "1h", "1d"
    lookback_periods: int = 100
    parameters: Dict[str, Any] = field(default_factory=dict)
    risk_parameters: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class StrategyState:
    """Current state of a strategy."""
    
    strategy_id: str
    is_active: bool
    positions: Dict[str, float]  # symbol -> quantity
    pending_orders: List[Dict[str, Any]]
    last_signal_time: Optional[datetime]
    performance_metrics: Dict[str, float]
    metadata: Dict[str, Any] = field(default_factory=dict)


class BaseStrategy(ABC):
    """
    Base class for all trading strategies.
    
    All trading strategies must inherit from this class and implement
    the required abstract methods. This ensures consistent interfaces
    for backtesting, paper trading, and live execution.
    
    Example:
        class SimpleMomentumStrategy(BaseStrategy):
            def __init__(self, config: StrategyConfig):
                super().__init__(config)
                self.momentum_period = config.parameters.get("momentum_period", 20)
            
            def generate_signals(self, market_data: pd.DataFrame) -> List[Signal]:
                signals = []
                for symbol in self.config.symbols:
                    momentum = self._calculate_momentum(market_data, symbol)
                    if momentum > self.threshold:
                        signals.append(Signal(
                            signal_type=SignalType.BUY,
                            symbol=symbol,
                            timestamp=datetime.utcnow(),
                            confidence=min(momentum / 100, 1.0),
                            strategy_id=self.config.strategy_id
                        ))
                return signals
    """
    
    def __init__(self, config: StrategyConfig):
        """
        Initialize the strategy with configuration.
        
        Args:
            config: Strategy configuration
        """
        self.config = config
        self._state = StrategyState(
            strategy_id=config.strategy_id,
            is_active=False,
            positions={},
            pending_orders=[],
            last_signal_time=None,
            performance_metrics={}
        )
        self._nano_models: Dict[str, Any] = {}
    
    @property
    def strategy_id(self) -> str:
        """Return the strategy identifier."""
        return self.config.strategy_id
    
    @property
    def is_active(self) -> bool:
        """Return whether the strategy is currently active."""
        return self._state.is_active
    
    @property
    def state(self) -> StrategyState:
        """Return the current strategy state."""
        return self._state
    
    @abstractmethod
    def generate_signals(self, market_data: pd.DataFrame) -> List[Signal]:
        """
        Generate trading signals based on market data.
        
        Args:
            market_data: DataFrame with OHLCV data and any additional features
            
        Returns:
            List of trading signals
        """
        pass
    
    @abstractmethod
    def calculate_position_size(
        self,
        signal: Signal,
        portfolio_value: float,
        current_positions: Dict[str, float]
    ) -> float:
        """
        Calculate the position size for a signal.
        
        Args:
            signal: The trading signal
            portfolio_value: Current portfolio value
            current_positions: Current positions by symbol
            
        Returns:
            Position size (quantity to trade)
        """
        pass
    
    @abstractmethod
    def validate_signal(
        self,
        signal: Signal,
        market_data: pd.DataFrame,
        current_positions: Dict[str, float]
    ) -> bool:
        """
        Validate a signal before execution.
        
        Performs risk checks and ensures the signal is valid given
        current market conditions and positions.
        
        Args:
            signal: The signal to validate
            market_data: Current market data
            current_positions: Current positions
            
        Returns:
            True if signal is valid for execution
        """
        pass
    
    def initialize(self) -> None:
        """
        Initialize the strategy before trading.
        
        Override this method to perform any setup needed before
        the strategy starts generating signals.
        """
        self._state.is_active = True
    
    def shutdown(self) -> None:
        """
        Shutdown the strategy.
        
        Override this method to perform any cleanup needed when
        the strategy stops trading.
        """
        self._state.is_active = False
    
    def on_order_filled(
        self,
        symbol: str,
        quantity: float,
        price: float,
        timestamp: datetime
    ) -> None:
        """
        Handle order fill notification.
        
        Args:
            symbol: The symbol that was filled
            quantity: Quantity filled (negative for sells)
            price: Fill price
            timestamp: Fill timestamp
        """
        current_qty = self._state.positions.get(symbol, 0.0)
        self._state.positions[symbol] = current_qty + quantity
        
        # Remove zero positions
        if abs(self._state.positions[symbol]) < 1e-10:
            del self._state.positions[symbol]
    
    def on_market_data(self, market_data: pd.DataFrame) -> None:
        """
        Handle new market data.
        
        Override this method to perform any updates needed when
        new market data arrives.
        
        Args:
            market_data: New market data
        """
        pass
    
    def register_nano_model(self, model_id: str, model: Any) -> None:
        """
        Register a nano model for use by the strategy.
        
        Args:
            model_id: Identifier for the model
            model: The nano model instance
        """
        self._nano_models[model_id] = model
    
    def get_nano_model(self, model_id: str) -> Any:
        """
        Get a registered nano model.
        
        Args:
            model_id: The model identifier
            
        Returns:
            The registered nano model
            
        Raises:
            KeyError: If model is not registered
        """
        if model_id not in self._nano_models:
            raise KeyError(f"Nano model {model_id} is not registered")
        return self._nano_models[model_id]
    
    def get_performance_metrics(self) -> Dict[str, float]:
        """
        Get current performance metrics.
        
        Returns:
            Dictionary of performance metrics
        """
        return self._state.performance_metrics.copy()
    
    def update_performance_metrics(self, metrics: Dict[str, float]) -> None:
        """
        Update performance metrics.
        
        Args:
            metrics: New metrics to merge
        """
        self._state.performance_metrics.update(metrics)
    
    def __repr__(self) -> str:
        return (
            f"{self.__class__.__name__}("
            f"strategy_id='{self.config.strategy_id}', "
            f"active={self._state.is_active})"
        )
