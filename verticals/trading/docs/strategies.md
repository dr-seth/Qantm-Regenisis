# Trading Strategies Guide

**Last Updated**: February 2026

## Overview

Trading strategies consume nano model outputs to generate trading signals. All strategies inherit from `BaseStrategy` and follow a consistent interface for backtesting and live execution.

## Strategy Types

### Momentum Strategies

Trend-following strategies that profit from price continuations.

- **Simple Momentum**: Basic momentum using price trends
- **Breakout**: Trade breakouts from consolidation patterns
- **Trend Following**: Follow established trends with trailing stops

### Mean Reversion Strategies

Strategies that profit from price reversals to the mean.

- **Pairs Trading**: Statistical arbitrage between correlated assets
- **Bollinger Bands**: Trade reversals at band extremes
- **RSI Reversal**: Trade oversold/overbought conditions

### Discovery-Generated Strategies

Strategies automatically generated by AARA's Discovery Engine.

- Evolved through genetic algorithms
- Validated via backtesting
- Tracked with full lineage

## Creating a New Strategy

### 1. Define the Strategy Class

```python
from verticals.trading.strategies.base import (
    BaseStrategy,
    StrategyConfig,
    Signal,
    SignalType
)
import pandas as pd
from typing import List, Dict

class SimpleMomentumStrategy(BaseStrategy):
    """Simple momentum strategy using price trends."""
    
    def __init__(self, config: StrategyConfig):
        super().__init__(config)
        self.lookback = config.parameters.get("lookback", 20)
        self.threshold = config.parameters.get("threshold", 0.02)
    
    def generate_signals(self, market_data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        for symbol in self.config.symbols:
            # Calculate momentum
            returns = market_data[symbol]["close"].pct_change(self.lookback)
            current_return = returns.iloc[-1]
            
            if current_return > self.threshold:
                signals.append(Signal(
                    signal_type=SignalType.BUY,
                    symbol=symbol,
                    timestamp=market_data.index[-1],
                    confidence=min(abs(current_return) / 0.1, 1.0),
                    strategy_id=self.config.strategy_id
                ))
            elif current_return < -self.threshold:
                signals.append(Signal(
                    signal_type=SignalType.SELL,
                    symbol=symbol,
                    timestamp=market_data.index[-1],
                    confidence=min(abs(current_return) / 0.1, 1.0),
                    strategy_id=self.config.strategy_id
                ))
        
        return signals
    
    def calculate_position_size(
        self,
        signal: Signal,
        portfolio_value: float,
        current_positions: Dict[str, float]
    ) -> float:
        # Risk-based position sizing
        max_position = portfolio_value * 0.02  # 2% max per position
        return max_position * signal.confidence
    
    def validate_signal(
        self,
        signal: Signal,
        market_data: pd.DataFrame,
        current_positions: Dict[str, float]
    ) -> bool:
        # Check if we already have a position
        current_qty = current_positions.get(signal.symbol, 0)
        
        if signal.signal_type == SignalType.BUY and current_qty > 0:
            return False  # Already long
        if signal.signal_type == SignalType.SELL and current_qty < 0:
            return False  # Already short
        
        return True
```

### 2. Register the Strategy

```python
from verticals.trading.strategies.registry import register_strategy

config = StrategyConfig(
    strategy_id="simple_momentum",
    name="Simple Momentum Strategy",
    description="Basic momentum strategy using price trends",
    symbols=["BTC/USDT", "ETH/USDT"],
    timeframe="1h",
    lookback_periods=100,
    parameters={
        "lookback": 20,
        "threshold": 0.02
    },
    risk_parameters={
        "max_position_pct": 0.02,
        "stop_loss_pct": 0.05
    }
)

@register_strategy("simple_momentum", config=config)
class SimpleMomentumStrategy(BaseStrategy):
    ...
```

### 3. Backtest the Strategy

```bash
python scripts/backtest_strategy.py \
    --strategy simple_momentum \
    --symbols BTC/USDT,ETH/USDT \
    --start 2024-01-01 \
    --end 2024-12-31
```

## Integrating Nano Models

Strategies can use nano models for enhanced predictions:

```python
class EnhancedMomentumStrategy(BaseStrategy):
    def initialize(self):
        super().initialize()
        
        # Register nano models
        from verticals.trading.nano_models.registry import get_model
        
        self.register_nano_model(
            "price_predictor",
            get_model("NM-TRADE-004")  # 1-hour price prediction
        )
        self.register_nano_model(
            "regime_classifier",
            get_model("NM-TRADE-009")  # Short-term regime
        )
    
    def generate_signals(self, market_data: pd.DataFrame) -> List[Signal]:
        # Get nano model predictions
        price_model = self.get_nano_model("price_predictor")
        regime_model = self.get_nano_model("regime_classifier")
        
        features = self._extract_features(market_data)
        price_pred = price_model.predict(features)
        regime_pred = regime_model.predict(features)
        
        # Only trade in trending regimes
        if regime_pred.prediction not in ["trending_up", "trending_down"]:
            return []
        
        # Generate signals based on predictions
        ...
```

## Strategy Lifecycle

1. **Development**: Create and test strategy locally
2. **Backtesting**: Validate on historical data
3. **Paper Trading**: Test with real market data, simulated execution
4. **Live Trading**: Deploy with real money (requires approval)
5. **Monitoring**: Track performance and adjust parameters
6. **Retirement**: Disable underperforming strategies

## Risk Management

### Position Sizing

Strategies must implement `calculate_position_size()` to determine trade sizes:

- **Fixed Fraction**: Fixed percentage of portfolio per trade
- **Volatility-Based**: Size inversely proportional to volatility
- **Kelly Criterion**: Optimal sizing based on win rate and payoff

### Stop Losses

Configure stop losses in `risk_parameters`:

```python
risk_parameters={
    "stop_loss_pct": 0.05,      # 5% stop loss
    "trailing_stop_pct": 0.03,  # 3% trailing stop
    "max_loss_per_trade": 1000  # $1000 max loss
}
```

### Position Limits

Enforce position limits to prevent over-concentration:

```python
risk_parameters={
    "max_position_pct": 0.02,   # 2% max per position
    "max_sector_pct": 0.10,     # 10% max per sector
    "max_open_positions": 5     # 5 max open positions
}
```

## Performance Metrics

Key metrics tracked for each strategy:

- **Total Return**: Overall profit/loss
- **Sharpe Ratio**: Risk-adjusted return
- **Max Drawdown**: Largest peak-to-trough decline
- **Win Rate**: Percentage of profitable trades
- **Profit Factor**: Gross profit / gross loss
- **Average Trade**: Average profit per trade
